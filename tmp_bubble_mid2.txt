const dx = bubble.x - otherBubble.x
            const dy = bubble.y - otherBubble.y
            const distance = Math.sqrt(dx * dx + dy * dy)
            const minDistance = bubble.radius + otherBubble.radius + 15 // Increased minimum distance

            if (distance < minDistance && distance > 0) {
              // Stronger separation force
              const angle = Math.atan2(dy, dx)
              const targetX = otherBubble.x + Math.cos(angle) * minDistance
              const targetY = otherBubble.y + Math.sin(angle) * minDistance

              // More aggressive separation
              const force = (minDistance - distance) / minDistance
              const ax = (targetX - bubble.x) * 0.1 * force // Increased force
              const ay = (targetY - bubble.y) * 0.1 * force

              bubble.vx += ax
              bubble.vy += ay

              // Add some randomness to prevent stuck situations
              if (Math.abs(bubble.vx) < 0.1 && Math.abs(bubble.vy) < 0.1) {
                bubble.vx += (Math.random() - 0.5) * 0.2
                bubble.vy += (Math.random() - 0.5) * 0.2
              }

              bubble.vx *= 0.98 // Less damping for more movement
              bubble.vy *= 0.98
            }
          }
        })

        // Add slight random movement to prevent stagnation
        if (Math.random() < 0.01) {
          // 1% chance per frame
          bubble.vx += (Math.random() - 0.5) * 0.1
          bubble.vy += (Math.random() - 0.5) * 0.1
        }

        // Limit maximum velocity to prevent chaos
        const maxVelocity = 1.5
        const currentSpeed = Math.sqrt(bubble.vx * bubble.vx + bubble.vy * bubble.vy)
        if (currentSpeed > maxVelocity) {
          bubble.vx = (bubble.vx / currentSpeed) * maxVelocity
          bubble.vy = (bubble.vy / currentSpeed) * maxVelocity
        }

        // Draw bubble with neon styling
        ctx.beginPath()
        ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2)

        // Create neon gradient fill
        const gradient = ctx.createRadialGradient(
          bubble.x - bubble.radius * 0.3,
          bubble.y - bubble.radius * 0.3,
          0,
          bubble.x,
          bubble.y,
          bubble.radius,
        )
        gradient.addColorStop(0, bubble.color + "90")
        gradient.addColorStop(0.7, bubble.color + "60")
        gradient.addColorStop(1, bubble.color + "30")
        ctx.fillStyle = gradient
        ctx.fill()

        // Add neon border
        ctx.strokeStyle = bubble.color
        ctx.lineWidth = 3
        ctx.stroke()

        // Add neon glow
        ctx.beginPath()
        ctx.arc(bubble.x, bubble.y, bubble.radius - 3, 0, Math.PI * 2)
        ctx.strokeStyle = bubble.color + "80"
        ctx.lineWidth = 2
        ctx.stroke()

        // Draw text with high contrast
        ctx.fillStyle = "#ffffff"
        ctx.font = "bold 11px Inter" // Slightly smaller font for smaller bubbles
        ctx.textAlign = "center"
        ctx.textBaseline = "middle"

        // Add text shadow for readability
        ctx.shadowColor = "rgba(0, 0, 0, 0.8)"
        ctx.shadowBlur = 4
        ctx.shadowOffsetX = 2
        ctx.shadowOffsetY = 2

        const text = bubble.skill
        const maxWidth = bubble.radius * 1.6

        // Smart text wrapping
        const words = text.split(" ")
        if (words.length > 1) {
          const line1 = words[0]
          const line2 = words.slice(1).join(" ")
          const line1Width = ctx.measureText(line1).width
          const line2Width = ctx.measureText(line2).width

          if (line1Width <= maxWidth && line2Width <= maxWidth) {
            ctx.fillText(line1, bubble.x, bubble.y - 6)
            ctx.fillText(line2, bubble.x, bubble.y + 6)
          } else {
            ctx.font = "bold 9px Inter"
            ctx.fillText(text, bubble.x, bubble.y)
          }
        } else {
          const textWidth = ctx.measureText(text).width
          if (textWidth <= maxWidth) {
            ctx.fillText(text, bubble.x, bubble.y)
          } else {
            ctx.font = "bold 9px Inter"
            ctx.fillText(text, bubble.x, bubble.y)
          }
        }

        // Reset shadow
        ctx.shadowColor = "transparent"
        ctx.shadowBlur = 0
        ctx.shadowOffsetX = 0
        ctx.shadowOffsetY = 0
      })

      // Draw neon connections
      bubbles.forEach((bubble1) => {
        const skill1Data = skillsData.find((s) => s.name === bubble1.skill)
        if (!skill1Data) return

        bubbles.forEach((bubble2) => {
          if (bubble1.id >= bubble2.id) return

          const skill2Data = skillsData.find((s) => s.name === bubble2.skill)
          if (!skill2Data) return

          const shouldConnect =
            skill1Data.connections.includes(skill2Data.name) || skill2Data.connections.includes(skill1Data.name)

          if (shouldConnect) {
            const dx = bubble1.x - bubble2.x
            const dy = bubble1.y - bubble2.y
            const distance = Math.sqrt(dx * dx + dy * dy)

            const maxDistance = 180 // Slightly reduced connection distance
            if (distance < maxDistance) {
              // Create neon gradient for connection lines
              const connectionGradient = ctx.createLinearGradient(bubble1.x, bubble1.y, bubble2.x, bubble2.y)
              connectionGradient.addColorStop(0, bubble1.color + "C0")
              connectionGradient.addColorStop(1, bubble2.color + "C0")

              ctx.beginPath()
              ctx.moveTo(bubble1.x, bubble1.y)
              ctx.lineTo(bubble2.x, bubble2.y)

              const opacity = Math.max(0.3, 0.8 * (1 - distance / maxDistance))

              if (bubble1.category === bubble2.category) {
                ctx.strokeStyle = connectionGradient
                ctx.lineWidth = 2
              } else {
                ctx.strokeStyle = connectionGradient
                ctx.lineWidth = 1
              }

              ctx.stroke()
            }
          }
        })
      })

      animationRef.current = requestAnimationFrame(animate)
    }

    animate()

    return () => {
      window.removeEventListener("resize", resizeCanvas)
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current)
      }
    }
  }, [])

  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 1 }}
      className="w-full h-[500px] rounded-lg bg-gradient-to-br from-background to-muted/30 border overflow-hidden" // Increased height from 384px to 500px
    >
      <canvas ref={canvasRef} className="w-full h-full" style={{ background: "transparent" }} />
    </motion.div>
  )
}
